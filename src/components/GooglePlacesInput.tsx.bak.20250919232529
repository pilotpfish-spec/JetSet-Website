import * as React from "react";

type Props = Omit<React.InputHTMLAttributes<HTMLInputElement>,"onChange"|"value"> & {
  value?: string;
  onChange?: (value: string) => void;
  placeholder?: string;
  restrictCountry?: string; // e.g., "us"
};

export default function GooglePlacesInput({
  value = "",
  onChange,
  className,
  placeholder = "Enter an address",
  restrictCountry = "us",
  ...rest
}: Props) {
  const [val, setVal] = React.useState(value ?? "");
  const [ready, setReady] = React.useState(false);
  const [preds, setPreds] = React.useState<Array<{ description: string; place_id: string }>>([]);
  const timerRef = React.useRef<number | null>(null);

  React.useEffect(() => setVal(value ?? ""), [value]);

  // Load Google Places script once
  React.useEffect(() => {
    if (typeof window === "undefined") return;
    const w = window as any;
    if (w.__googlePlacesLoaded) { setReady(true); return; }
    const apiKey = process.env.NEXT_PUBLIC_GOOGLE_MAPS_API_KEY;
    if (!apiKey) { console.warn("NEXT_PUBLIC_GOOGLE_MAPS_API_KEY missing"); return; }
    if (document.getElementById("__gplaces")) { return; }

    const s = document.createElement("script");
    s.id = "__gplaces";
    s.src = `https://maps.googleapis.com/maps/api/js?key=${apiKey}&libraries=places&language=en`;
    s.async = true;
    s.onload = () => { (window as any).__googlePlacesLoaded = true; setReady(true); };
    document.head.appendChild(s);
  }, []);

  const fetchPredictions = React.useCallback((q: string) => {
    const google = (window as any).google;
    if (!google?.maps?.places?.AutocompleteService) return;
    const svc = new google.maps.places.AutocompleteService();
    svc.getPlacePredictions(
      {
        input: q,
        componentRestrictions: restrictCountry ? { country: restrictCountry } : undefined,
      },
      (results: any[], status: string) => {
        if (status !== "OK" || !Array.isArray(results)) { setPreds([]); return; }
        setPreds(results.map(r => ({ description: r.description, place_id: r.place_id })));
      }
    );
  }, [restrictCountry]);

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const v = e.currentTarget.value;
    setVal(v);
    onChange?.(v);
    if (!ready) return;
    if (timerRef.current) window.clearTimeout(timerRef.current);
    timerRef.current = window.setTimeout(() => fetchPredictions(v), 250);
  };

  const pick = (desc: string) => {
    setVal(desc);
    onChange?.(desc);
    setPreds([]);
  };

  return (
    <div className="relative">
      <input
        className={className || "w-full rounded-xl border px-3 py-2"}
        type="text"
        inputMode="text"
        autoComplete="street-address"
        placeholder={placeholder}
        value={val}
        onChange={handleChange}
        {...rest}
      />
      {preds.length > 0 && (
        <ul className="absolute z-50 mt-1 max-h-64 w-full overflow-auto rounded-xl border bg-white shadow">
          {preds.map(p => (
            <li
              key={p.place_id}
              className="cursor-pointer px-3 py-2 hover:bg-slate-50"
              onMouseDown={(e) => { e.preventDefault(); pick(p.description); }}
            >
              {p.description}
            </li>
          ))}
        </ul>
      )}
    </div>
  );
}
